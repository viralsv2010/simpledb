package simpledb;

import java.util.*;
import java.util.function.Consumer;
import java.io.*;

import jdk.management.resource.internal.TotalResourceContext;

/**
 * A {@code HeapPage} is a collection of {@code Tuple}s. A fixed-size memory space is used for each {@code HeapPage}. A
 * {@code HeapFile} consists of {@code HeaPage}s. The {@code HeapPage} class implements the {@code Page} interface that
 * is used by {@code BufferPool}.
 * 
 * @see HeapFile
 * @see BufferPool
 */
public class HeapPage implements Page {

	/**
	 * The ID of this {@code HeapPage}.
	 */
	HeapPageId pid;

	/**
	 * The {@code TupleDesc} representing the {@code Tuple}s stored in this {@code HeapPage}.
	 */
	TupleDesc td;

	/**
	 * The current content of this {@code HeapPage}.
	 */
	byte[] data;

	/**
	 * The previous image of this {@code HeapPage}.
	 */
	byte[] oldData;

	/**
	 * A flag indicating whether or not this {@code HeapPage} is dirty.
	 */
	boolean dirty;

	/**
	 * The ID of the transaction that modified this {@code HeapPage}.
	 */
	private TransactionId tid;

	/**
	 * Creates a {@code HeapPage} from a byte array storing data read from disk. This byte array contains (1) a 4-byte
	 * integer representing the number of {@code Tuple}s assigned to the {@code HeapPage}, (2) a sequence of integer
	 * values each of which indicates where the corresponding {@code Tuple} is stored in the byte array, (3) a free
	 * space reserved for storing additional {@code Tuple}s, and (4) a sequence of {@code Tuple}s.
	 * 
	 * @param id
	 *            the ID of the {@code HeapPage}.
	 * @param data
	 *            a byte array storing the data to read.
	 * @see Database#getCatalog
	 * @see Catalog#getTupleDesc
	 * @see BufferPool#PAGE_SIZE
	 */
	public HeapPage(HeapPageId id, byte[] data) throws IOException {
		this.pid = id;
		this.td = Database.getCatalog().getTupleDesc(id.getTableId());
		this.data = data;
		setBeforeImage();
	}

	/**
	 * Generates a byte array representing the contents of this {@code HeapPage}. This method is used to serialize this
	 * {@code HeapPage} to disk.
	 * <p>
	 * The invariant here is that it should be possible to pass the byte array generated by this method to the
	 * {@code HeapPage} constructor and have it produce an identical {@code HeapPage}.
	 * 
	 * @see #HeapPage
	 * @return a byte array correspond to the content of this {@code HeapPage}.
	 */
	public byte[] getPageData() {
		return data;
	}

	/**
	 * @return the ID of this {@code HeapPage}.
	 */
	public HeapPageId getId() {
		return pid;
	}

	/**
	 * Returns {@code Tuple} at the specified entry.
	 * 
	 * @param entryID
	 *            the ID of the entry at which the {@code Tuple} is stored.
	 */
	public Tuple getTuple(int entryID) {
		
		System.out.println("Entry ID is :: " + entryID + "Entry Count is :: " + entryCount());
		
		// Checking the Tuple ID value is greater than zero and less than total entry count.
		if(entryID >= 0 && entryID  < entryCount())
		{
			// locationOfTuple is the tuple Location.
			int locationOfTuple = tupleLocation(entryID);
			
			System.out.println("Location :: " + locationOfTuple + " data ::" + data + " datalength :: " + (data.length - locationOfTuple));
			
			// Creating DataInputStream to access InputStream data
			DataInputStream in = new DataInputStream(new ByteArrayInputStream(data, locationOfTuple, data.length - locationOfTuple));
			
			// Creating Tuple for obtaining particular tuple with entryID
			Tuple t = createTuple(in);
			
			// Setting the Record by Registering the ID of the page as pid and the entry storing the Tuple as entryID
			t.setRecordId(new RecordId(pid, entryID));
			
			System.out.println("TUple :: " + t);
			
			return t;
		}
		else
		{
			return null;
		}
	}

	/**
	 * @return an iterator over all {@code Tuple}s on this {@code HeapPage} (calling remove on this iterator throws an
	 *         {@code UnsupportedOperationException}) (note that this iterator shouldn't return {@code Tuples} in empty
	 *         slots!)
	 */
	public Iterator<Tuple> iterator() {
		// Making List of type Tuples as we have to iterate through each of them.
		List<Tuple> list = new LinkedList<Tuple>();
		// Loop through each Tuple and Adding it to the above created List.
		for (int i=0; i< entryCount(); i++){
			Tuple addTuple = getTuple(i);
			list.add(addTuple);
		}
		// returning the List Iterator.
		return list.iterator();
		
//		Iterator<Tuple> iterate = new Iterator<Tuple>(){};
//		for (int i=0; i< entryCount(); i++){
//			iterate.add(getTuple(i));
//		}
//		for (int i=0; i< entryCount(); i++){
//			System.out.println("Iterator :: "+ iterate.toString());
//		}
//		
//		return iterate;
		
		
//		final ArrayList<Tuple> arrayList = null;
//		Iterator<Tuple> it = new Iterator<Tuple>(){
//			int location = 0;
//			int totalLength = entryCount();
//			public boolean hasNext()
//			{
//				if( location < totalLength)
//				{
//					arrayList.add(getTuple(location));
//					return true;
//				}
//				else
//				{
//					return false;
//				}
//			}
//			public void forEachRemaining(Consumer<? super Tuple> arg0) {
//				// TODO Auto-generated method stub
//				
//			}
//			public Tuple next() {
//				// TODO Auto-generated method stub
//				return null;
//			}
//			public void remove() {
//				// TODO Auto-generated method stub
//				
//			}
//		};
//		return it;
	}	

	/**
	 * Deletes the specified {@code Tuple} from this {@code HeapPage}; the {@code Tuple} should be updated to reflect
	 * that it is no longer stored on any page.
	 * 
	 * @throws DbException
	 *             if the {@code Tuple} is not on this {@code HeapPage}, or the {@code Tuple} slot is already empty.
	 * @param t
	 *            the {@code Tuple} to delete
	 */
	public void deleteTuple(Tuple t) throws DbException {
		// some code goes here
		
		// Getting the Tuple ID
		RecordId recordid = t.getRecordId();
//		if(recordid == null)
//		{
//			throw new DbException("Tuple do not exist.");
//		}
//		else
//		{
			// Getting the Tuple_ID
			int tuple_id = t.getRecordId().tupleno;
			
			// Getting the pageid associated with this tuple.
			PageId page_of_Tuple = recordid.getPageId();
			
			//checking whether it matches with the current pid of heap page.
			// If not then throw DB Exception.
			if(page_of_Tuple != pid)
			{
				throw new DbException(" Tuple do not Exist.");
			}
			else
			{
				 //Getting the location of Tuple
				 int locationOfTuple = tupleLocation(tuple_id);
				 
				 // If location Of Tuple is -1 then it is already deleted.
				 if(locationOfTuple == -1)
				 {
					 throw new DbException("Tuple is already deleted.");
				 }
				 else
				 {
					 	//System.out.println("Data at Location after change :: " + data[locationOfTuple]);

						saveTupleLocation(tuple_id , -1);
				}
			}
//			Tuple org_Tuple = getTuple(tuple_id);
//			
//			byte[] old = toByteArray(t);
//			byte[] org = toByteArray(org_Tuple);
//			if( old == org )
//			{
//				
			
			
//			int locationOfTuple = tupleLocation(tuple_id);
//			
//			System.out.println("Inside Delete tuple :: Tuple id :: " + tuple_id +  
//				"Tuple Location :: " + locationOfTuple	);
//			
//			locationOfTuple = -1;
//		
//
//			saveTupleLocation(tuple_id, locationOfTuple);
			
			
//			
//			 //Getting the location of Tuple
//			 int locationOfTuple = tupleLocation(tuple_id);
//			 
//			 if(locationOfTuple == -1)
//			 {
//				 throw new DbException("Tuple is already deleted.");
//			 }
//			 else
//			 {
//			
//				 System.out.println("Tuple ID :: " + tuple_id + " Tuple Location :: " + locationOfTuple + "Data At Location :: " + data[tuple_id]);
			
//			for(int i=0; i< data.length ; i++)
//			{
//				System.out.println("data byte array :: " + " i: " + i + " " + data[i] + " Data Length :: " + data.length);
//			}

			// Putting the value of that tuple as -1.
			//data[tuple_id] = -1;
			
			//writeInt(data, locationOfTuple, -1);
			
//			 	System.out.println("Data at Location after change :: " + data[locationOfTuple]);
//
//				saveTupleLocation(tuple_id , -1);
//			 }
//			 }
//			}
//			 else
//			 {
//				 System.out.println("No");
//			 }
	
//		}	 
		
		//throw new UnsupportedOperationException("Implement this");
	}

	/**
	 * Adds the specified {@code Tuple} to this {@code HeapPage}; the {@code Tuple} should be updated to reflect that it
	 * is now stored on this {@code HeapPage}.
	 * 
	 * @throws DbException
	 *             if this {@code HeapPage} is full (no empty slots).
	 * @param t
	 *            the {@code Tuple} to add.
	 */
	public void addTuple(Tuple t) throws DbException {
		
		// Creating byte array to create the tuple.
		byte tuplebyteArray[] = toByteArray(t);
		
		// Calculate the Free space.
		int freeSpace = freeSpaceSize();
		
		// Checking that If there is a free space to accommodate the page.
		// If not then we will throw db exception.
		if(freeSpace < tuplebyteArray.length + 4)
		{
			throw new DbException("There is no free space.");
		}
		else
		{
			// Find the Location where can we add the Tuple.
			int locationToAddTuple = endOfFreeSpace() - tuplebyteArray.length;
			
			System.out.println("Tuple Length to add :: " + tuplebyteArray.length + " End of freee space :: " + endOfFreeSpace());
		
			// Copying the byte Array into the Page.
			
			System.arraycopy(tuplebyteArray, 0, data, locationToAddTuple, tuplebyteArray.length);
			System.out.println("Location to add tuple :: " + locationToAddTuple);
			
			// Increasing the total number of pages in header file
			saveEntryCount(entryCount() + 1);
			
			// Saving the Tuple Location
			//int tuple_id = t.getRecordId().tupleno;
			int tuple_id = entryCount() - 1;

			saveTupleLocation(tuple_id, locationToAddTuple);
			
			// Register the ID of the page and the entry storing the tuple. 
			t.setRecordId(new RecordId(pid, tuple_id));
		}
	}

	/**
	 * Marks this {@code HeapPage} as dirty/not dirty and record that transaction that did the dirtying
	 */
	public void markDirty(boolean dirty, TransactionId tid) {
		this.dirty = dirty;
		this.tid = tid;
	}

	/**
	 * Returns the tid of the transaction that last dirtied this page, or null if the page is not dirty
	 */
	public TransactionId isDirty() {
		if (dirty)
			return tid;
		else
			return null;
	}

	/**
	 * Returns a view of this {@code HeapPage} before it was modified -- used by recovery
	 */
	public HeapPage getBeforeImage() {
		try {
			return new HeapPage(pid, oldData);
		} catch (IOException e) {
			e.printStackTrace();
			// should never happen -- we parsed it OK before!
			System.exit(1);
		}
		return null;
	}

	public void setBeforeImage() {
		oldData = getPageData().clone();
	}

	/**
	 * Generates a byte array corresponding to an empty {@code HeapPage}. This method is used to add new, empty pages to
	 * the file. Passing the results of this method to the {@code HeapPage} constructor will create a {@code HeapPage}
	 * with no valid {@code Tuple}s in it.
	 * 
	 * @return the created byte array.
	 */
	public static byte[] createEmptyPageData() {
		int len = BufferPool.PAGE_SIZE;
		return new byte[len]; // all 0
	}

	/**
	 * Writes an integer value at the specified location of a byte array.
	 * 
	 * @param data
	 *            a byte array.
	 * @param location
	 *            a location in the byte array.
	 * @param value
	 *            the value to write.
	 */
	protected void writeInt(byte[] data, int location, int value) {
		data[location] = (byte) (value >>> 24);
		data[location + 1] = (byte) (value >>> 16);
		data[location + 2] = (byte) (value >>> 8);
		data[location + 3] = (byte) value;
	}

	/**
	 * Reads an integer at the specified location of a byte array.
	 * 
	 * @param data
	 *            a byte array.
	 * @param location
	 *            a location in the byte array.
	 * @return an integer read at the specified location of a byte array.
	 */
	protected int readInt(byte[] data, int location) {
		return ((data[location]) << 24) + ((data[location + 1] & 0xFF) << 16) + ((data[location + 2] & 0xFF) << 8)
				+ (data[location + 3] & 0xFF);
	}

	/**
	 * Returns a byte array representing the specified tuple.
	 * 
	 * @param t
	 *            a tuple.
	 * @return a byte array representing the specified tuple.
	 */
	protected byte[] toByteArray(Tuple t) {
		ByteArrayOutputStream b = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(b);
		try {
			for (int j = 0; j < t.fields.length; j++) {
				Field f = t.getField(j);
				f.serialize(out);
			}
			out.flush();
			b.flush();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return b.toByteArray();
	}

	/**
	 * Constructs a tuple by reading data from the specified {@code DataInputStream}.
	 * 
	 * @param in
	 *            a {@code DataInputStream}.
	 * @return a tuple constructed from the specified {@code DataInputStream}.
	 */
	protected Tuple createTuple(DataInputStream in) {
		try {
			Tuple t = new Tuple(td);
			for (int j = 0; j < td.numFields(); j++) {
				Field f = td.getType(j).parse(in);
				t.setField(j, f);
			}
			return t;
		} catch (java.text.ParseException e) {
			e.printStackTrace();
			throw new NoSuchElementException("parsing error!");
		}
	}

	/**
	 * Returns the number of entries in this {@code HeapPage}.
	 * 
	 * @return the number of entries in this {@code HeapPage}.
	 */
	protected int entryCount() {
		// Returning the number of Tuples in the HeapPage. 
		// Here, Location '0' says the first block in HeapPage 
		// which is total number of entries in HeapPage.
		return readInt(data,0);
		//throw new UnsupportedOperationException("Implement this");
	}

	/**
	 * Finds (by examining the header of this {@code HeapPage}) the location of the tuple at the specified entry.
	 * 
	 * @param entryID
	 *            the ID of the entry.
	 * @return the location of the tuple at the specified entry.
	 */
	protected int tupleLocation(int entryID) {
		// Returning the Particular location of Tuple.
		// Here, First 4 bytes shows the first block which contains
		// Total number of Tuples. Then, To move to Tuple for entryID
		// we have to go 4 times to entryID as each block is of 4 bytes.
		return readInt(data, 4 + 4 * entryID);
	}

	/**
	 * Saves (in the header of this {@code HeapPage}) the number of entries managed by this {@code HeapPage}.
	 * 
	 * @param count
	 *            the number of entries in this {@code HeapPage}.
	 */
	protected void saveEntryCount(int count) {
		System.out.println("Count is :: " + count);
		writeInt(data, 0, count);
	}

	/**
	 * Saves (in the header of this {@code HeapPage}) the location of the specified tuple.
	 * 
	 * @param entryID
	 *            the ID of the entry at which the tuple is stored.
	 * @param location
	 *            the location of the tuple.
	 */
	protected void saveTupleLocation(int entryID, int location) {
		writeInt(data, 4 + 4 * entryID, location);
	}

	/**
	 * Returns the size of free space in this {@code HeapPage}.
	 * 
	 * @return the size of free space in this {@code HeapPage}.
	 */
	public int freeSpaceSize() {
		return endOfFreeSpace() - headerSize();
	}

	/**
	 * Returns the size of the header in this {@code HeapPage}.
	 * 
	 * @return the size of the header in this {@code HeapPage}.
	 */
	protected int headerSize() {
		return 4 + 4 * entryCount();
	}

	/**
	 * Returns the end location of the free space in this {@code HeapPage}.
	 * 
	 * @return the end location of the free space in this {@code HeapPage}.
	 */
	protected int endOfFreeSpace() {
		int count = entryCount();
		for (int i = count - 1; i >= 0; i--) {
			int location = tupleLocation(i);
			if (location != -1) {
				return location;
			}
		}
		return BufferPool.PAGE_SIZE;
	}

	/**
	 * Compacts this {@code HeapPage}.
	 */
	protected void compact() {
		// some code goes here
		// not necessary for assignment1
		throw new UnsupportedOperationException("Implement this");
	}

}
